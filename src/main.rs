// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
extern crate num_bigint;
extern crate risc0_zkvm;
extern crate zk_auctions_core;
extern crate zk_auctions_methods;

pub mod host;
pub mod examples;

use num_bigint::BigInt;

use examples::run_two_bidders_example;
use examples::run_n_bidders_example;
use examples::web_server::start_web_server;

fn main() {
    println!("==================================================================================");
    println!("ZERO-KNOWLEDGE AUCTION PROTOCOL - 4 PHASE IMPLEMENTATION");
    println!("==================================================================================");
    println!("This implementation follows a 4-phase zero-knowledge auction protocol:");
    println!("");
    println!("PHASE 1: BIDDERS JOIN");
    println!("  - Each bidder generates GM keypair and encrypts their bid");
    println!("  - Runs in parallel for efficiency");
    println!("  - Output: (n_j, c_j, r_j, (p_j, q_j)) for each bidder");
    println!("");
    println!("PHASE 2: BIDDER PROVE");
    println!("  - Each bidder 'j' runs bidder_prove against bidder 'i'");
    println!("  - 'j' = bidder running proof, 'i' = other bidder being compared");
    println!("  - Generates zero-knowledge proofs of bid validity");
    println!("");
    println!("PHASE 3: AUCTIONEER VERIFY");
    println!("  - Auctioneer verifies all proof_eval from all bidders");
    println!("  - Ensures all bidders provided valid zero-knowledge proofs");
    println!("  - Auctioneer acts as trusted verifier");
    println!("");
    println!("PHASE 4: BIDDER VERIFY ALL & WINNER DETERMINATION");
    println!("  - Each bidder verifies other bidders' proofs using bidder_verify_all");
    println!("  - Verifies proof_enc (encryption) and proof_dlog (discrete log)");
    println!("  - Ensures mutual verification between bidders");
    println!("  - Final bid comparison using compare_leq_honest");
    println!("  - Determines winner by comparing against all other bidders");
    println!("  - Runs in parallel for efficiency");
    println!("==================================================================================");
    
    // Choose which example to run
    // Check if an argument was passed to override the default
    let args: Vec<String> = std::env::args().collect();
    let run_example = if args.len() > 1 {
        args[1].parse::<i32>().unwrap_or(3)
    } else {
        3 // Default to web server
    };
    
    if run_example == 1 {
        // Example 1: Run the fixed two-bidders example
        println!("Running Example 1: Two Bidders Example");
        run_two_bidders_example();
    } else if run_example == 2 {
        // Example 2: Run the configurable n-bidders example
        println!("Running Example 2: N Bidders Example (Configurable)");
        let bidders = vec![
            ("Alice".to_string(), BigInt::from(1500)),
            ("Bob".to_string(), BigInt::from(5000)),
            ("Oscar".to_string(), BigInt::from(10000)),
        ];
        run_n_bidders_example(bidders);
    } else if run_example == 3 {
        // Example 3: Start web server with real-time log streaming
        println!("Running Example 3: Web Server with Real-Time Logs");
        start_web_server();
    } else {
        println!("Invalid example number. Please set run_example to 1, 2, or 3.");
    }
}
