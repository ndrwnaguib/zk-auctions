// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
extern crate num_bigint;
extern crate risc0_zkvm;
extern crate zk_auctions_core;
extern crate zk_auctions_methods;

use num_bigint::{BigInt, RandBigInt};
use risc0_zkvm::{default_prover, ExecutorEnv};
use std::collections::HashMap;
use zk_auctions_core::gm::{encrypt_gm, generate_keys, get_next_random};
use zk_auctions_core::utils::{rand32, StrainProof};
use zk_auctions_methods::{GUEST_ELF, GUEST_ID};

fn main() {
    let mut rng = rand::thread_rng();

    let keys1 = generate_keys(None);
    let n_i = &keys1.pub_key;

    let v_i: BigInt = rng.gen_bigint_range(&BigInt::from(0u32), &(BigInt::from(1u32) << 31));
    let r_i = rand32(n_i);
    let c_i = encrypt_gm(&v_i, n_i);

    let sound_param: usize = 40;
    let sigma: BigInt = BigInt::from(40);

    let mut rand1: Vec<Vec<BigInt>> = Vec::with_capacity(32);
    let mut rand2: Vec<Vec<BigInt>> = Vec::with_capacity(32);
    let mut rand3: Vec<Vec<BigInt>> = Vec::with_capacity(32);
    let mut rand4: Vec<Vec<BigInt>> = Vec::with_capacity(32);

    for _ in 0..32 {
        let mut x = Vec::with_capacity(128);
        let mut y = Vec::with_capacity(128);
        let mut x2 = Vec::with_capacity(128);
        let mut y2 = Vec::with_capacity(128);
        for _ in 0..128 {
            x.push(get_next_random(n_i));
            y.push(get_next_random(n_i));
            x2.push(get_next_random(n_i));
            y2.push(get_next_random(n_i));
        }
        rand1.push(x);
        rand2.push(y);
        rand3.push(x2);
        rand4.push(y2);
    }

    let env = ExecutorEnv::builder()
        .write(&(c_i.clone(), n_i.clone(), r_i.clone()))
        .expect("Failed to add encryption proof input")
        .write(&(c_i.clone(), n_i.clone(), sound_param))
        .expect("Failed to add evaluation proof input")
        .write(&sigma)
        .expect("Failed to add discrete-log input")
        .write(&(rand1, rand2, rand3, rand4))
        .expect("Failed to add shuffle proof input")
        .build()
        .expect("Failed to build execution environment");

    let prover = default_prover();
    println!("Attempting at unwraping receipt");
    let receipt = prover.prove(env, GUEST_ELF).unwrap().receipt;

    println!("Attempting at unwraping receipt, after verifying");
    receipt.verify(GUEST_ID).unwrap();

    println!("Attempting at decoding `proof_enc`");
    let proof_enc: Vec<Vec<Vec<BigInt>>> =
        receipt.journal.decode().expect("Failed to decode `proof_enc`");
    println!("Successfully decoded `proof_enc`");

    println!("Attempting at decoding `proof_eval, plaintext_and_coins`");
    let (proof_eval, plaintext_and_coins): (
        Vec<Vec<Vec<BigInt>>>,
        Vec<Vec<(BigInt, BigInt, BigInt)>>,
    ) = receipt.journal.decode().expect("Failed to decode proof_eval and plaintext_and_coins");
    println!("Successfully decoded `proof_eval, plaintext_and_coins`");

    println!("Attempting at decoding `proof_dlog_eq`");
    let proof_dlog_eq: Vec<(BigInt, BigInt, BigInt)> =
        receipt.journal.decode().expect("Failed to decode proof_dlog_eq");
    println!("Successfully decoded `proof_dlog_eq`");

    println!("Attempting at decoding `proof_shuffle`");
    let proof_shuffle: HashMap<usize, StrainProof> =
        receipt.journal.decode().expect("Failed to decode `proof_shuffle`");
    println!("Successfully decoded `proof_shuffle`");
}
