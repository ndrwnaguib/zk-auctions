// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
extern crate num_bigint;
extern crate risc0_zkvm;
extern crate zk_auctions_core;
extern crate zk_auctions_methods;

pub mod host;
pub mod examples;

use num_bigint::BigInt;

use examples::run_two_bidders_example;
use examples::run_n_bidders_example;
use examples::web_server::start_web_server;

fn main() {
    println!("==================================================================================");
    println!("ZERO-KNOWLEDGE AUCTION PROTOCOL - 4 PHASE IMPLEMENTATION");
    println!("==================================================================================");
    println!("This implementation follows a 4-phase zero-knowledge auction protocol:");
    println!("");
    println!("PHASE 1: BIDDERS JOIN");
    println!("  - Each bidder generates GM keypair and encrypts their bid");
    println!("  - Runs in parallel for efficiency");
    println!("  - Output: (n_j, c_j, r_j, (p_j, q_j)) for each bidder");
    println!("");
    println!("PHASE 2: BIDDER PROVE");
    println!("  - Each bidder 'j' runs bidder_prove against bidder 'i'");
    println!("  - 'j' = bidder running proof, 'i' = other bidder being compared");
    println!("  - Generates zero-knowledge proofs of bid validity");
    println!("");
    println!("PHASE 3: AUCTIONEER VERIFY");
    println!("  - Auctioneer verifies all proof_eval from all bidders");
    println!("  - Ensures all bidders provided valid zero-knowledge proofs");
    println!("  - Auctioneer acts as trusted verifier");
    println!("");
    println!("PHASE 4: BIDDER VERIFY ALL & WINNER DETERMINATION");
    println!("  - Each bidder verifies other bidders' proofs using bidder_verify_all");
    println!("  - Verifies proof_enc (encryption) and proof_dlog (discrete log)");
    println!("  - Ensures mutual verification between bidders");
    println!("  - Final bid comparison using compare_leq_honest");
    println!("  - Determines winner by comparing against all other bidders");
    println!("  - Runs in parallel for efficiency");
    println!("==================================================================================");
    
    // Choose which example to run
    // Check if an argument was passed to override the default
    let args: Vec<String> = std::env::args().collect();
    let run_example = if args.len() > 1 {
        match args[1].parse::<i32>() {
            Ok(val) => val,
            Err(e) => {
                eprintln!(
                    "Warning: failed to parse argument '{}' as an integer ({}). Defaulting to 3 (web server).",
                    args[1],
                    e
                );
                3
            }
        }
    } else {
        3 // Default to web server
    };
    
    if run_example == 1 {
        // Example 1: Run the fixed two-bidders example
        println!("Running Example 1: Two Bidders Example");
        run_two_bidders_example();
    } else if run_example == 2 {
        // Example 2: Run the configurable n-bidders example
        println!("Running Example 2: N Bidders Example (Configurable)");
        
        // Parse bidder names and values from command-line arguments if provided
        let bidders = if args.len() >= 4 {
            // args[2] = comma-separated bidder names (e.g., "Bob,Alice")
            // args[3] = comma-separated bid values (e.g., "5000,3000")
            let names: Vec<String> = args[2].split(',').map(|s| s.trim().to_string()).collect();
            let values: Vec<BigInt> = args[3]
                .split(',')
                .map(|s| {
                    let trimmed = s.trim();
                    match trimmed.parse::<i64>() {
                        Ok(v) => v,
                        Err(e) => {
                            eprintln!(
                                "Warning: unable to parse bid value '{}': {}. Falling back to 1000.",
                                trimmed,
                                e
                            );
                            1000
                        }
                    }
                })
                .map(BigInt::from)
                .collect();
            
            println!("Received {} bidder names: {:?}", names.len(), names);
            println!("Received {} bid values: {:?}", values.len(), values);
            
            // Combine names and values
            names.iter()
                .zip(values.iter())
                .map(|(name, value)| (name.clone(), value.clone()))
                .collect()
        } else {
            // Default bidders if no arguments provided
            println!("No command-line arguments provided, using default bidders");
            vec![
                ("Alice".to_string(), BigInt::from(1500)),
                ("Bob".to_string(), BigInt::from(5000)),
                ("Oscar".to_string(), BigInt::from(10000)),
            ]
        };
        
        run_n_bidders_example(bidders);
    } else if run_example == 3 {
        // Example 3: Start web server with real-time log streaming
        println!("Running Example 3: Web Server with Real-Time Logs");
        start_web_server();
    } else {
        println!("Invalid example number. Please set run_example to 1, 2, or 3.");
    }
}
