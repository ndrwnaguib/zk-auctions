// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
extern crate num_bigint;
extern crate risc0_zkvm;
extern crate zk_auctions_core;
extern crate zk_auctions_methods;


pub mod strain;
use strain::auctioneer::AuctioneerHost;
use strain::bidder::BidderHost;
use zk_auctions_core::protocols::strain::bidder::StrainBidderHost;
use zk_auctions_core::protocols::strain::auctioneer::StrainAuctioneerHost;

use num_bigint::BigInt;
use risc0_zkvm::Receipt;
use zk_auctions_core::protocols::strain::StrainSecurityParams;

/// Configuration for a bidder in the auction
#[derive(Debug, Clone)]
pub struct BidderConfig {
    pub name: String,
    pub bid_value: BigInt,
}

/// Result of the auction process
#[derive(Debug)]
pub struct AuctionResult {
    pub winner_name: String,
    pub winner_bid: BigInt,
    pub winner_index: usize,
    pub all_bids: Vec<(String, BigInt)>,
}

/// Run a complete auction scenario with n bidders
pub fn run_auction_scenario(bidder_configs: Vec<BidderConfig>) -> AuctionResult {
    let num_bidders = bidder_configs.len();
    println!("Starting auction with {} bidders", num_bidders);

    // Print bidder information
    for (i, config) in bidder_configs.iter().enumerate() {
        println!("Bidder {}: {} with bid ${}", i, config.name, config.bid_value);
    }

    // Shared soundness parameters
    let soundness = StrainSecurityParams::default();

    // PHASE 1: JOIN PHASE
    println!("\n=== PHASE 1: JOIN PHASE ===");
    println!("Auctioneer starts auction with 1 minute join time...");

    // Create auctioneer
    let mut auctioneer = AuctioneerHost::new(soundness.clone());

    // Create bidders - each bidder joins the auction
    let mut bidders: Vec<BidderHost> = Vec::new();
    for config in &bidder_configs {
        // println!("{} joining auction with bid ${}...", config.name, config.bid_value);
        let bidder = BidderHost::new(config.bid_value.clone(), soundness.clone());
        bidders.push(bidder);
    }

    println!("All {} bidders have joined the auction", num_bidders);

    // PHASE 2: EVALUATION PHASE
    println!("\n=== PHASE 2: EVALUATION PHASE ===");

    // 2.1 Each bidder sends their c_i, n_i, r_i to other bidders
    println!("2.1 Bidders exchanging encrypted bids and public keys...");

    // 2.2 Each bidder generates proofs against every other bidder
    println!("2.2 Bidders generating proofs against each other...");
    let mut all_proofs: Vec<Vec<(Receipt, Vec<u8>)>> = Vec::new();

    // First, collect all the public information from bidders
    let mut bidder_public_info: Vec<(Vec<BigInt>, BigInt, Vec<BigInt>)> = Vec::new();
    for bidder in &bidders {
        bidder_public_info.push((
            bidder.get_c_j().clone(),
            bidder.get_n_j().clone(),
            bidder.get_r_j().clone(),
        ));
    }

    // Now generate proofs using the collected public information
    for j in 0..bidders.len() {
        let mut bidder_proofs: Vec<(Receipt, Vec<u8>)> = Vec::new();

        for i in 0..bidders.len() {
            if i == j {
                continue; // Skip self-comparison
            }

            // Bidder j proves against bidder i using collected public info
            let (c_i, n_i, r_i) = &bidder_public_info[i];
            let proof = bidders[j].prove(c_i, n_i, r_i);
            bidder_proofs.push(proof);
            println!(
                "  {} generated proof against {}",
                bidder_configs[j].name, bidder_configs[i].name
            );
        }

        all_proofs.push(bidder_proofs);
    }

    // 2.3 Each bidder sends their receipts and private outputs to auctioneer for verification
    println!("2.3 Bidders sending proofs to auctioneer for verification...");
    let mut auctioneer_verification_results: Vec<Vec<bool>> = Vec::new();

    for (bidder_idx, proofs) in all_proofs.iter().enumerate() {
        let mut bidder_verification_results: Vec<bool> = Vec::new();

        for (proof_idx, (receipt, private_output)) in proofs.iter().enumerate() {
            let other_bidder_idx = if proof_idx >= bidder_idx { proof_idx + 1 } else { proof_idx };
            let is_verified = auctioneer.verify(receipt, private_output);
            bidder_verification_results.push(is_verified);

            if is_verified {
                println!(
                    "  âœ“ Auctioneer verified {}'s proof against {}",
                    bidder_configs[bidder_idx].name, bidder_configs[other_bidder_idx].name
                );
            } else {
                println!(
                    "  âœ— Auctioneer failed to verify {}'s proof against {}",
                    bidder_configs[bidder_idx].name, bidder_configs[other_bidder_idx].name
                );
            }
        }

        auctioneer_verification_results.push(bidder_verification_results);
    }

    // 2.4 Bidders exchange receipts for verification
    println!("2.4 Bidders exchanging receipts for verification...");

    // PHASE 3: SELECTING WINNER
    println!("\n=== PHASE 3: SELECTING WINNER ===");

    // 3.1 Check if all auctioneer verifications passed
    println!("3.1 Checking auctioneer verification results...");
    let mut all_auctioneer_verifications_passed = true;

    for (bidder_idx, verification_results) in auctioneer_verification_results.iter().enumerate() {
        for (proof_idx, &is_verified) in verification_results.iter().enumerate() {
            if !is_verified {
                all_auctioneer_verifications_passed = false;
                let other_bidder_idx =
                    if proof_idx >= bidder_idx { proof_idx + 1 } else { proof_idx };
                println!(
                    "  âœ— {}'s proof against {} failed auctioneer verification",
                    bidder_configs[bidder_idx].name, bidder_configs[other_bidder_idx].name
                );
            }
        }
    }

    if !all_auctioneer_verifications_passed {
        panic!("Auctioneer verification failed - cannot proceed to winner selection");
    }

    println!("  âœ“ All auctioneer verifications passed");

    // 3.2 Each bidder verifies other bidders and determines winner
    println!("3.2 Bidders performing verification and comparison...");

    let mut bidder_wins: Vec<usize> = vec![0; num_bidders]; // Count wins for each bidder

    for i in 0..bidders.len() {
        // Collect all receipts where other bidders proved against bidder i
        let mut receipts_for_bidder_i: Vec<Receipt> = Vec::new();
        
        for j in 0..bidders.len() {
            if i == j {
                continue; // Skip self
            }
            
            // Get the receipt where bidder j was the prover against bidder i
            let receipt_idx = if j < i { j } else { j - 1 };
            let (ref receipt, _) = all_proofs[j][receipt_idx];
            receipts_for_bidder_i.push(receipt.clone());
        }

        // Bidder i verifies all other bidders' proofs against them
        let revealed_bid = bidders[i].verify_other_bidders(&receipts_for_bidder_i);
        
        if let Some(revealed_value) = revealed_bid {
            bidder_wins[i] += 1;
            println!(
                "  âœ“ {} verified all other bidders' proofs and WON with revealed bid ${}",
                bidder_configs[i].name, revealed_value
            );
        } else {
            println!(
                "  âœ— {} lost the auction (verification failed or bid was lower)",
                bidder_configs[i].name
            );
        }
    }

    // Determine the winner (bidder with most wins)
    let max_wins = bidder_wins.iter().max().unwrap();
    let winner_indices: Vec<usize> = bidder_wins
        .iter()
        .enumerate()
        .filter(|(_, &wins)| wins == *max_wins)
        .map(|(idx, _)| idx)
        .collect();

    if winner_indices.len() != 1 {
        panic!("Auction error: Expected exactly 1 winner, but found {} winners with {} wins each. This indicates a problem with the verification logic.", winner_indices.len(), max_wins);
    }

    let winner_idx = winner_indices[0];
    let winner_config = &bidder_configs[winner_idx];

    println!("\nðŸŽ‰ AUCTION COMPLETED!");
    println!("Winner: {} with bid ${}", winner_config.name, winner_config.bid_value);
    println!("Total pairwise comparisons: {}", num_bidders * (num_bidders - 1));

    // Create result
    let all_bids: Vec<(String, BigInt)> = bidder_configs
        .iter()
        .map(|config| (config.name.clone(), config.bid_value.clone()))
        .collect();

    AuctionResult {
        winner_name: winner_config.name.clone(),
        winner_bid: winner_config.bid_value.clone(),
        winner_index: winner_idx,
        all_bids,
    }
}

fn main() {
    // Example: 3 bidders scenario
    let bidder_configs = vec![
        BidderConfig { name: "Alice".to_string(), bid_value: BigInt::from(1000u32) },
        BidderConfig { name: "Bob".to_string(), bid_value: BigInt::from(1500u32) },
        // BidderConfig { name: "Charlie".to_string(), bid_value: BigInt::from(800u32) },
    ];

    let result = run_auction_scenario(bidder_configs);

    println!("\n=== FINAL RESULTS ===");
    println!(
        "Winner: {} (Bidder {}) with bid ${}",
        result.winner_name, result.winner_index, result.winner_bid
    );
    println!("All bids:");
    for (name, bid) in result.all_bids {
        println!("  {}: ${}", name, bid);
    }
}
