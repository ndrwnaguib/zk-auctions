// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
extern crate num_bigint;
extern crate risc0_zkvm;
extern crate zk_auctions_core;
extern crate zk_auctions_methods;

pub mod auctioneer_host;
pub mod bidder_host;

use crate::auctioneer_host::AuctioneerHost;
use crate::bidder_host::BidderHost;
use num_bigint::{BigInt, RandBigInt};
use rand::Rng;
use risc0_zkvm::Receipt;
use zk_auctions_core::protocols::strain::StrainSecurityParams;

fn run_four_bidders_scenario() {
    // Shared soundness parameters
    let soundness = StrainSecurityParams::default();

    // Create auctioneer
    let mut auctioneer = AuctioneerHost::new(soundness.clone());

    // Create 4 bidders with different specific bid values
    let bid_values = vec![
        BigInt::from(1000u32), // Bidder 0: $1000
        BigInt::from(1500u32), // Bidder 1: $1500
        BigInt::from(800u32),  // Bidder 2: $800
        BigInt::from(2000u32), // Bidder 3: $2000
    ];

    let mut bidders: Vec<BidderHost> =
        bid_values.into_iter().map(|v| BidderHost::new(v, soundness.clone())).collect();

    // Helper function to get receipt index for bidder i proving against bidder j
    let get_receipt_index = |i: usize, j: usize| -> usize {
        if j < i {
            j
        } else {
            j - 1
        }
    };

    // For n bidders, we need n*(n-1) pairwise comparisons
    // Each bidder (j) proves against every other bidder (i)
    let mut all_proofs: Vec<Vec<(Receipt, Vec<u8>)>> = Vec::new();

    // Generate proofs for each bidder against every other bidder
    for j in 0..bidders.len() {
        let mut bidder_proofs: Vec<(Receipt, Vec<u8>)> = Vec::new();

        for i in 0..bidders.len() {
            if i == j {
                continue; // Skip self-comparison
            }

            // Bidder j proves against bidder i
            // j is the prover (*_j), i is the other bidder (*_i)
            let proof = bidders[j].prove(
                bidders[i].get_c_j(), // c_i: encrypted bid of bidder i
                bidders[i].get_n_j(), // n_i: public key of bidder i
                bidders[i].get_r_j(), // r_i: random values of bidder i
            );
            bidder_proofs.push(proof);
        }

        all_proofs.push(bidder_proofs);
    }

    // Auctioneer verifies each receipt + private output and records bidders
    for (bidder_idx, receipts) in all_proofs.iter().enumerate() {
        for (proof_idx, (receipt, private_output)) in receipts.iter().enumerate() {
            let other_bidder_idx = if proof_idx >= bidder_idx { proof_idx + 1 } else { proof_idx };
            let is_verified = auctioneer.verify(receipt, private_output);
            assert!(
                is_verified,
                "Auctioneer failed to verify bidder {} against bidder {}",
                bidder_idx, other_bidder_idx
            );
        }
    }

    // Each bidder verifies every other bidder
    for i in 0..bidders.len() {
        for j in 0..bidders.len() {
            if i == j {
                continue;
            }
            // Get the receipt where bidder i was the prover against bidder j
            let receipt_idx = get_receipt_index(i, j);
            let (ref receipt, _) = all_proofs[i][receipt_idx];
            let is_verified = bidders[i].verify_other_bidder(receipt);
            assert!(is_verified, "Bidder {} failed to verify bidder {}", i, j);
        }
    }

    println!("Scenario completed: all verifications passed for 4 bidders and 1 auctioneer.");
    println!("Total pairwise comparisons: {}", bidders.len() * (bidders.len() - 1));
}

fn main() {
    run_four_bidders_scenario();
}
