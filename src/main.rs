// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
extern crate num_bigint;
extern crate risc0_zkvm;
extern crate zk_auctions_core;
extern crate zk_auctions_methods;

use num_bigint::BigInt;
use num_traits::One;
 
use risc0_zkvm::{default_prover, serde::from_slice, ExecutorEnv};
use std::collections::HashMap;
use std::thread;
use std::sync::mpsc;
use zk_auctions_core::gm::{get_next_random, generate_keys, encrypt_gm};
use zk_auctions_core::utils::rand32;
use zk_auctions_core::protocols::strain::auctioneer::{Auctioneer, StrainAuctioneer};
use zk_auctions_core::utils::{
    compare_leq_honest, get_rand_jn1, hash_flat, set_rand_seed, StrainProof,
};
use zk_auctions_methods::{BIDDER_PROVER_ELF, BIDDER_PROVER_ID, BIDDER_JOIN_ELF};

// Struct to store bidder prove results
#[derive(Clone)]
struct BidderProveResult {
    proof_eval: Vec<Vec<Vec<BigInt>>>,
    plaintext_and_coins: Vec<Vec<(BigInt, BigInt, BigInt)>>,
    n_j_from_proof: BigInt,
    proof_enc: Vec<Vec<Vec<BigInt>>>,
    proof_dlog: Vec<(BigInt, BigInt, BigInt)>,
    y_j: BigInt,
    y_pow_r: BigInt,
    z_pow_r: BigInt,
    proof_shuffle: HashMap<u32, StrainProof>,
    res: Vec<Vec<BigInt>>,
    receipt: risc0_zkvm::Receipt,
    other_bidder_id: String,
}

fn auctioneer_verify(
    proof_eval: &Vec<Vec<Vec<BigInt>>>,
    plaintext_and_coins: &Vec<Vec<(BigInt, BigInt, BigInt)>>,
    n_i: &BigInt,
    n_j: &BigInt,
    sound_param: usize,
) {
    let auctioneer = Auctioneer::new();
    let eval_res = Some(auctioneer.verify_eval(
        proof_eval.clone(),
        plaintext_and_coins.clone(),
        n_i,
        n_j,
        sound_param,
    ));
    assert!(eval_res.is_some(), "`proof_eval` verification failed.");
    println!("[(auctioneer)-host] proof_eval verification passed.");
}

fn auctioneer_verify_all(
    phase2_results: &HashMap<String, Vec<BidderProveResult>>,
    bidders_data: &HashMap<String, (BigInt, BigInt, BigInt)>, // (n_i, p_i, q_i) for each bidder
    sound_param: usize,
) -> bool {
    println!("[(auctioneer)-host] PHASE 3: Auctioneer Verify - Verifying all evaluation proofs and receipts from all bidders...");
    
    let mut all_verifications_passed = true;
    
    // Verify all results from all bidders
    for (bidder_id, results) in phase2_results {
        println!("[(auctioneer)-host] Verifying {} results for bidder: {}", results.len(), bidder_id);
        
        for (i, result) in results.iter().enumerate() {
            println!("[(auctioneer)-host] Verifying result {} for bidder {} vs {}", i + 1, bidder_id, result.other_bidder_id);
            
            // First verify the receipt
            match result.receipt.verify(BIDDER_PROVER_ID) {
                Ok(_) => {
                    // Receipt verification passed
                },
                Err(_e) => {
                    // Receipt verification failed
                    all_verifications_passed = false;
                    continue; // Skip other verifications if receipt fails
                }
            }
            
            // Get the corresponding bidder i data for verification
            let (n_i, p_i, q_i) = bidders_data.get(bidder_id).unwrap();
            
            // println!("[(auctioneer)-host] Verifying proof_eval for {} vs {}", bidder_id, result.other_bidder_id);
            // println!("[host] proof_eval = {:?}", result.proof_eval);
            // println!("[host] plaintext_and_coins = {:?}", result.plaintext_and_coins);
            // println!("[(auctioneer)-host] n_i = {:?}", n_i);
            // println!("[(auctioneer)-host] n_j_from_proof = {:?}", result.n_j_from_proof);
            // println!("[host] sound_param = {:?}", sound_param);

            // Verify this specific proof_eval
            match std::panic::catch_unwind(|| {
                auctioneer_verify(&result.proof_eval, &result.plaintext_and_coins, n_i, &result.n_j_from_proof, sound_param);
            }) {
                Ok(_) => {
                    println!("[(auctioneer)-host] âœ… Verification PASSED for {} result {} vs {}", bidder_id, i + 1, result.other_bidder_id);
                },
                Err(_) => {
                    println!("[(auctioneer)-host] âŒ Verification FAILED for {} result {} vs {}", bidder_id, i + 1, result.other_bidder_id);
                    all_verifications_passed = false;
                }
            }
        }
    }
    
    if all_verifications_passed {
        println!("[(auctioneer)-host] âœ… ALL auctioneer verifications PASSED - Proceeding to Phase 4");
    } else {
        println!("[(auctioneer)-host] âŒ Some auctioneer verifications FAILED - Stopping protocol");
    }
    
    all_verifications_passed
}

fn bidder_join(bidder_id: String, bid_value: BigInt) -> (BigInt, Vec<BigInt>, Vec<BigInt>, (BigInt, BigInt)) {
    println!("[host] Starting bidder_join for bidder: {}", bidder_id);
    
    // Create environment for the bidder_join guest method
    let mut private_output = Vec::new();
    let env = ExecutorEnv::builder()
        .write(&bidder_id)
        .expect("Failed to add bidder_id")
        .write(&bid_value)
        .expect("Failed to add bid_value")
        .stdout(&mut private_output)
        .build()
        .unwrap();
    
    println!("[host] ExecutorEnv built for bidder_join. Running zkVM...");
    
    // Run the bidder_join guest method
    let session = default_prover();
    let receipt = session.prove(env, BIDDER_JOIN_ELF).unwrap().receipt;
    println!("[host] zkVM proof generated for bidder_join. Verifying...");
    
    // Read private output (private key components)
    let (p_j, q_j): (BigInt, BigInt) = from_slice(&private_output)
        .expect("Failed to deserialize private key data");
    
    // Read public output from journal
    let (n_j, c_j, r_j): (BigInt, Vec<BigInt>, Vec<BigInt>) = receipt.journal.decode()
        .expect("Failed to decode public results");
    
    println!("[host] Bidder {} generated public key n_j = {}", bidder_id, n_j);
    println!("[host] Bidder {} encrypted value c_j (len={})", bidder_id, c_j.len());
    
    (n_j, c_j, r_j, (p_j, q_j))
}

fn mock_bidder_join(bidder_id: String, bid_value: BigInt) -> (BigInt, Vec<BigInt>, Vec<BigInt>, (BigInt, BigInt)) {
    println!("[host] Starting mock_bidder_join for bidder: {}", bidder_id);
    
    // Generate keys using pure Rust (same as zkVM version)
    let keys_j = generate_keys(None);
    let n_j = keys_j.pub_key;
    let (p_j, q_j) = keys_j.priv_key;
    
    // Generate random values using pure Rust
    let r_j: Vec<BigInt> = rand32(&n_j);
    
    // Encrypt the bid value using pure Rust
    let c_j = encrypt_gm(&bid_value, &n_j);
    
    println!("[host] Mock bidder {} generated public key n_j = {}", bidder_id, n_j);
    println!("[host] Mock bidder {} encrypted value c_j (len={})", bidder_id, c_j.len());
    
    (n_j, c_j, r_j, (p_j, q_j))
}

fn bidders_prove_all(
    bidders: Vec<(String, BigInt, Vec<BigInt>, Vec<BigInt>, BigInt, BigInt, BigInt)>, // (id, n, c, r, v, p, q)
    sound_param: usize,
    sigma: BigInt,
) -> HashMap<String, Vec<BidderProveResult>> {
    println!("[host] PHASE 2: Running bidder_prove in parallel for all bidder pairs...");
    
    let mut results: HashMap<String, Vec<BidderProveResult>> = HashMap::new();
    let (tx, rx) = mpsc::channel();
    
    // Create all possible bidder pairs
    let mut threads = Vec::new();
    
    for i in 0..bidders.len() {
        for j in 0..bidders.len() {
            if i != j {
                let (bidder_i_id, n_i, c_i, r_i, v_i, p_i, q_i) = bidders[i].clone();
                let (bidder_j_id, n_j, c_j, r_j, v_j, p_j, q_j) = bidders[j].clone();
                let tx_clone = tx.clone();
                let sigma_clone = sigma.clone();
                
                let handle = thread::spawn(move || {
                    println!("[host] Starting bidder_prove: {} vs {}", bidder_j_id, bidder_i_id);
                    
                    let (proof_eval, plaintext_and_coins, n_j_from_proof, proof_enc, (proof_dlog, y_j, y_pow_r, z_pow_r), (proof_shuffle, res), receipt) = 
                        bidder_prove(bidder_j_id.clone(), c_i, n_i, r_i, n_j, r_j, v_j, p_j, q_j, sound_param, sigma_clone);
                    
                    let result = BidderProveResult {
                        proof_eval,
                        plaintext_and_coins,
                        n_j_from_proof,
                        proof_enc,
                        proof_dlog,
                        y_j,
                        y_pow_r,
                        z_pow_r,
                        proof_shuffle,
                        res,
                        receipt,
                        other_bidder_id: bidder_i_id.clone(),
                    };
                    
                    println!("[host] Completed bidder_prove: {} vs {}", bidder_j_id, bidder_i_id);
                    tx_clone.send((bidder_j_id, bidder_i_id, result)).unwrap();
                });
                
                threads.push(handle);
            }
        }
    }
    
    // Collect results
    for _ in 0..threads.len() {
        let (bidder_j_id, bidder_i_id, result) = rx.recv().unwrap();
        results.entry(bidder_j_id).or_insert_with(Vec::new).push(result);
    }
    
    // Wait for all threads to complete
    for handle in threads {
        handle.join().unwrap();
    }
    
    println!("[host] PHASE 2: All bidder_prove operations completed");
    results
}

fn bidder_prove(
    bidder_id: String,
    c_i: Vec<BigInt>,
    n_i: BigInt,
    r_i: Vec<BigInt>,
    n_j: BigInt,
    r_j: Vec<BigInt>,
    v_j: BigInt,
    p_j: BigInt,
    q_j: BigInt,
    sound_param: usize,
    sigma: BigInt,
) -> (
    Vec<Vec<Vec<BigInt>>>,
    Vec<Vec<(BigInt, BigInt, BigInt)>>,
    BigInt,
    Vec<Vec<Vec<BigInt>>>,
    (Vec<(BigInt, BigInt, BigInt)>, BigInt, BigInt, BigInt),
    (HashMap<u32, StrainProof>, Vec<Vec<BigInt>>),
    risc0_zkvm::Receipt,
) {
    let mut rand1: Vec<Vec<BigInt>> = Vec::with_capacity(32);
    let mut rand2: Vec<Vec<BigInt>> = Vec::with_capacity(32);
    let mut rand3: Vec<Vec<BigInt>> = Vec::with_capacity(32);
    let mut rand4: Vec<Vec<BigInt>> = Vec::with_capacity(32);

    for _ in 0..32 {
        let mut x = Vec::with_capacity(128);
        let mut y = Vec::with_capacity(128);
        let mut x2 = Vec::with_capacity(128);
        let mut y2 = Vec::with_capacity(128);
        for _ in 0..128 {
            x.push(get_next_random(&n_i));
            y.push(get_next_random(&n_i));
            x2.push(get_next_random(&n_i));
            y2.push(get_next_random(&n_i));
        }
        rand1.push(x);
        rand2.push(y);
        rand3.push(x2);
        rand4.push(y2);
    }

    let mut private_output = Vec::new();
    println!("[({})-host] Building ExecutorEnv...", bidder_id);
    let env = ExecutorEnv::builder()
        .write(&bidder_id)
        .expect("Failed to add guest_id")
        .write(&(&n_j, &r_j, &v_j, &p_j, &q_j))
        .expect("Failed to add bidder j data")
        .write(&(&c_i, &n_i, &r_i))
        .expect("Failed to add bidder i data")
        .write(&(&sigma, &(sound_param as u32)))
        .expect("Failed to add parameters")
        .write(&(&rand1, &rand2, &rand3, &rand4))
        .expect("Failed to add random values")
        .stdout(&mut private_output)
        .build()
        .unwrap();
    println!("[({})-host] ExecutorEnv built successfully.", bidder_id);

    let session = default_prover();
    println!("[({})-host] Running zkVM (prove)...", bidder_id);
    let receipt = session.prove(env, BIDDER_PROVER_ELF).unwrap().receipt;
    println!("[({})-host] zkVM proof generated.", bidder_id);

    println!("[({})-host] Reading private output...", bidder_id);
    let (proof_eval, plaintext_and_coins): (
        Vec<Vec<Vec<BigInt>>>,
        Vec<Vec<(BigInt, BigInt, BigInt)>>,
    ) = from_slice(&private_output).expect("Failed to deserialize private data");
    println!("[({})-host] Private output deserialization successful.", bidder_id);

    println!("[({})-host] Decoding public results from journal...", bidder_id);
    let (n_j, proof_enc, proof_dlog_tuple, proof_shuffle_tuple): (
        BigInt,
        Vec<Vec<Vec<BigInt>>>,
        (Vec<(BigInt, BigInt, BigInt)>, BigInt, BigInt, BigInt),
        (HashMap<u32, StrainProof>, Vec<Vec<BigInt>>),
    ) = receipt.journal.decode().expect("Failed to decode all results");
    println!("[({})-host] Got n_j = {}", bidder_id, n_j);

    (proof_eval, plaintext_and_coins, n_j, proof_enc, proof_dlog_tuple, proof_shuffle_tuple, receipt)
}

fn bidder_verify(
    bidder_label: &str,
    proof_enc: Vec<Vec<Vec<BigInt>>>,
    proof_dlog: Vec<(BigInt, BigInt, BigInt)>,
    y_j: BigInt,
    y_pow_r: BigInt,
    z_pow_r: BigInt,
    n_j_from_proof: &BigInt,
    sound_param: usize,
    res: Vec<Vec<BigInt>>,
    p_i: BigInt,
    q_i: BigInt,
) -> bool {
    println!("[({})-host] Verifying proof_enc...", bidder_label);
    assert!(verify_proof_enc(proof_enc));
    println!("[({})-host] proof_enc verification passed.", bidder_label);

    println!("[({})-host] Verifying dlog proof...", bidder_label);
    assert!(verify_dlog_eq(n_j_from_proof, &y_j, &y_pow_r, &z_pow_r, &proof_dlog, Some(sound_param)));
    println!("[({})-host] dlog proof verification passed.", bidder_label);

    // Final bid comparison using private key
    println!("[({})-host] Comparing bids using compare_leq_honest...", bidder_label);
    let comparison_result = compare_leq_honest(&res, &(p_i, q_i));
    
    if comparison_result {
        println!("[({})-host] Other bidder's bid is <= current bidder's bid. Continuing...", bidder_label);
        true
    } else {
        println!("[({})-host] Other bidder's bid is > current bidder's bid. Not winner.", bidder_label);
        false
    }
}

fn bidder_verify_all(
    phase2_results: &HashMap<String, Vec<BidderProveResult>>,
    bidders_data: &HashMap<String, (BigInt, BigInt, BigInt)>, // (n_i, p_i, q_i) for each bidder
    sound_param: usize,
) -> HashMap<String, bool> {
    let mut winner_results: HashMap<String, bool> = HashMap::new();
    let (tx, rx) = mpsc::channel();
    let mut threads = Vec::new();
    
    // Clone the data for use in threads
    let phase2_results_clone = phase2_results.clone();
    let bidders_data_clone = bidders_data.clone();
    
    // For each bidder, create a thread to verify all results where they are the "other bidder"
    for (bidder_id, _results) in phase2_results {
        let bidder_id_clone = bidder_id.clone();
        let phase2_results_thread = phase2_results_clone.clone();
        let bidders_data_thread = bidders_data_clone.clone();
        let tx_clone = tx.clone();
        
        let handle = thread::spawn(move || {
            println!("[({})-host] Starting verification for bidder: {}", bidder_id_clone, bidder_id_clone);
            
            // A bidder is a winner if they beat ALL other bidders
            // We need to find results where this bidder compared against others
            // and verify that this bidder's bid was higher in ALL comparisons
            let mut is_winner = true;
            let mut comparisons_checked = 0;
            
            // Look for results where this bidder (bidder_id_clone) compared against others
            if let Some(this_bidder_results) = phase2_results_thread.get(&bidder_id_clone) {
                for result in this_bidder_results {
                    // This result is from bidder_id_clone comparing against some other bidder
                    println!("[({})-host] Verifying result against {}", bidder_id_clone, result.other_bidder_id);
                    
                    // Get the private key for the current bidder (bidder_id_clone)
                    let (_n_i, p_i, q_i) = bidders_data_thread.get(&bidder_id_clone).unwrap();
                    
                    // Verify this result
                    let comparison_result = bidder_verify(
                        &bidder_id_clone,
                        result.proof_enc.clone(),
                        result.proof_dlog.clone(),
                        result.y_j.clone(),
                        result.y_pow_r.clone(),
                        result.z_pow_r.clone(),
                        &result.n_j_from_proof,
                        sound_param,
                        result.res.clone(),
                        p_i.clone(),
                        q_i.clone(),
                    );
                    
                    comparisons_checked += 1;
                    
                    // If comparison_result is true, it means this bidder's bid is > other bidder's bid
                    // If comparison_result is false, it means this bidder's bid is <= other bidder's bid
                    if !comparison_result {
                        println!("[({})-host] Lost against another bidder", bidder_id_clone);
                        is_winner = false;
                        break;
                    } else {
                        println!("[({})-host] Beat another bidder", bidder_id_clone);
                    }
                }
            } else {
                println!("[({})-host] No results found for bidder {}", bidder_id_clone, bidder_id_clone);
                is_winner = false;
            }
            
            println!("[({})-host] Verification complete. Is winner: {} (checked {} comparisons)", 
                     bidder_id_clone, is_winner, comparisons_checked);
            tx_clone.send((bidder_id_clone, is_winner)).unwrap();
        });
        
        threads.push(handle);
    }
    
    // Collect results
    for _ in 0..threads.len() {
        let (bidder_id, is_winner) = rx.recv().unwrap();
        winner_results.insert(bidder_id, is_winner);
    }
    
    // Wait for all threads to complete
    for handle in threads {
        handle.join().unwrap();
    }
    
    // Announce winner
    for (bidder_id, is_winner) in &winner_results {
        if *is_winner {
            println!("[host] ðŸ† WINNER: {} is the auction winner!", bidder_id);
        } else {
            println!("[host] âŒ {} is not the winner", bidder_id);
        }
    }
    
    winner_results
}

fn run_two_bidders_example() { 
    // ==================================================================================
    // PHASE 1: BIDDERS JOIN - Generate keys and encrypt bid values
    // ==================================================================================
    // Each bidder generates their own GM keypair (n_j, p_j, q_j) and encrypts their bid
    // This phase runs in parallel for all bidders to reduce total execution time
    // Output: Each bidder gets (n_j, c_j, r_j, (p_j, q_j)) where:
    //   - n_j: public key
    //   - c_j: encrypted bid value  
    //   - r_j: random values used in encryption
    //   - (p_j, q_j): private key components
    // ==================================================================================
    println!("[host] ==================================================================================");
    println!("[host] PHASE 1: Bidders Join - Generating keys and encrypting bids...");
    println!("[host] ==================================================================================");
    
    // Create channels for communication between threads
    let (tx, rx) = mpsc::channel();
    
    // Spawn first bidder thread
    let tx1 = tx.clone();
    let handle1 = thread::spawn(move || {
        let v_i: BigInt = BigInt::from(1500);
        println!("[host] Starting bidder1 thread with bid v_i = {}", v_i);
        let result = mock_bidder_join("bidder1".to_string(), v_i.clone());
        println!("[host] Bidder1 thread completed");
        tx1.send(("bidder1", v_i, result)).unwrap();
    });
    
    // Spawn second bidder thread
    let handle2 = thread::spawn(move || {
        let v_j: BigInt = BigInt::from(2000);
        println!("[host] Starting bidder2 thread with bid v_j = {}", v_j);
        let result = mock_bidder_join("bidder2".to_string(), v_j.clone());
        println!("[host] Bidder2 thread completed");
        tx.send(("bidder2", v_j, result)).unwrap();
    });
    
    // Wait for both threads to complete and collect results
    println!("[host] Waiting for both bidders to complete...");
    let mut bidder1_result = None;
    let mut bidder2_result = None;
    
    for _ in 0..2 {
        let (bidder_id, bid_value, (n, c, r, (p, q))) = rx.recv().unwrap();
        match bidder_id {
            "bidder1" => {
                bidder1_result = Some((n, c, r, (p, q), bid_value));
                println!("[host] Received bidder1 results");
            },
            "bidder2" => {
                bidder2_result = Some((n, c, r, (p, q), bid_value));
                println!("[host] Received bidder2 results");
            },
            _ => panic!("Unknown bidder ID"),
        }
    }
    
    // Join threads to ensure they're finished
    handle1.join().unwrap();
    handle2.join().unwrap();
    
    // Extract results
    let (n_1, c_1, r_1, (p_1, q_1), v_1) = bidder1_result.unwrap();
    let (n_2, c_2, r_2, (p_2, q_2), v_2) = bidder2_result.unwrap();
    // Preserve bid values for final logging before moves elsewhere
    let v1_for_log = v_1.clone();
    let v2_for_log = v_2.clone();
    
    println!("[host] First bidder's bid v_1 = {}", v_1);
    println!("[host] Second bidder's bid v_2 = {}", v_2);

    // ==================================================================================
    // PHASE 2: BIDDER PROVE - Each bidder runs bidder_prove against other bidders
    // ==================================================================================
    // Each bidder "j" runs the zkVM bidder_prove guest method with respect to bidder "i"
    // - "j" = the bidder running the proof (me)
    // - "i" = the other bidder being compared against
    // This generates zero-knowledge proofs that bidder j's bid is valid
    // Output: proof_eval, proof_enc, proof_dlog, and comparison results
    // ==================================================================================
    println!("[host] ==================================================================================");
    println!("[host] PHASE 2: Bidder Prove - Generating zero-knowledge proofs in parallel...");
    println!("[host] ==================================================================================");

    let sound_param: usize = 40;
    let sigma: BigInt = BigInt::from(40);
    println!("[host] sound_param = {} sigma = {}", sound_param, sigma);

    // Store bidder data before moving into bidders vector
    let bidder1_data = (n_1.clone(), p_1.clone(), q_1.clone());
    let bidder2_data = (n_2.clone(), p_2.clone(), q_2.clone());
    
    // Store copies for later use (not used in current implementation)
    let _p_1_copy = bidder1_data.1.clone();
    let _q_1_copy = bidder1_data.2.clone();
    
    // Prepare bidders data for parallel processing
    let bidders = vec![
        ("bidder1".to_string(), n_1, c_1, r_1, v_1, p_1, q_1),
        ("bidder2".to_string(), n_2, c_2, r_2, v_2, p_2, q_2),
    ];

    // Run Phase 2 in parallel
    let phase2_results = bidders_prove_all(bidders, sound_param, sigma);

    // ==================================================================================
    // PHASE 3: AUCTIONEER VERIFY - Verify all proof_eval from all bidders
    // ==================================================================================
    // The auctioneer verifies the evaluation proofs (proof_eval) from all bidders
    // This ensures that all bidders have provided valid zero-knowledge proofs
    // The auctioneer acts as a trusted verifier in this phase
    // Only proceed to Phase 4 if ALL verifications pass
    // ==================================================================================
    
    // Prepare bidders data for verification
    let mut bidders_data = HashMap::new();
    bidders_data.insert("bidder1".to_string(), bidder1_data);
    bidders_data.insert("bidder2".to_string(), bidder2_data);
    
    // Verify all results using the cleaner function
    if !auctioneer_verify_all(&phase2_results, &bidders_data, sound_param) {
        println!("[host] Protocol stopped due to verification failures");
        return;
    }

    // ==================================================================================
    // PHASE 4: BIDDER VERIFY ALL - Each bidder verifies other bidders' results in parallel
    // ==================================================================================
    // Each bidder verifies the proofs from other bidders using bidder_verify_all
    // This includes verifying proof_enc (encryption proof) and proof_dlog (discrete log proof)
    // This ensures mutual verification between bidders
    // Also includes the final bid comparison using compare_leq_honest
    // Each bidder determines if they are the winner by comparing against all other bidders
    // ==================================================================================
    
    // Run the comprehensive bidder verification
    let winner_results = bidder_verify_all(&phase2_results, &bidders_data, sound_param);
    
    // Final winner announcement (only show winner id and bid value if there is exactly one)
    let mut winners = Vec::new();
    for (bidder_id, is_winner) in &winner_results {
        if *is_winner {
            winners.push(bidder_id);
        }
    }
    if winners.len() == 1 {
        let winner_id = winners[0];
        let winner_bid = if winner_id == &"bidder1" { v1_for_log } else { v2_for_log };
        println!("[host] ðŸŽ‰ WINNER: {} (Bid: {})", winner_id, winner_bid);
    }
}

fn run_n_bidders_example(bidders: Vec<(String, BigInt)>) {
    // ==================================================================================
    // N-BIDDER AUCTION PROTOCOL - Configurable bidders with names and bid values
    // ==================================================================================
    println!("[host] ==================================================================================");
    println!("[host] Starting N-Bidder Auction Protocol...");
    println!("[host] ==================================================================================");
    
    let num_bidders = bidders.len();
    let sound_param: usize = 40;
    let sigma: BigInt = BigInt::from(40);
    
    println!("[host] Running auction with {} bidders", num_bidders);
    println!("[host] Bidders: {:?}", bidders);
    println!("[host] sound_param = {} sigma = {}", sound_param, sigma);

    // ==================================================================================
    // PHASE 1: BIDDERS JOIN - Generate keys and encrypt bid values (parallel)
    // ==================================================================================
    println!("[host] ==================================================================================");
    println!("[host] PHASE 1: Bidders Join - Generating keys and encrypting bids for {} bidders...", num_bidders);
    println!("[host] ==================================================================================");

    let (tx, rx) = mpsc::channel();
    let mut threads = Vec::new();
    
    for (bidder_id, bid_value) in bidders {
        let tx_clone = tx.clone();
        
        let handle = thread::spawn(move || {
            println!("[host] Starting {} thread with bid v = {}", bidder_id, bid_value);
            let result = mock_bidder_join(bidder_id.clone(), bid_value.clone());
            println!("[host] {} thread completed", bidder_id);
            tx_clone.send((bidder_id, bid_value, result)).unwrap();
        });
        
        threads.push(handle);
    }
    
    // Collect results from all bidders
    let mut bidder_results = HashMap::new();
    for _ in 0..num_bidders {
        let (bidder_id, bid_value, (n, c, r, (p, q))) = rx.recv().unwrap();
        bidder_results.insert(bidder_id.clone(), (n, c, r, p, q, bid_value));
        println!("[host] Received {} results", bidder_id);
    }
    
    // Wait for all threads to complete
    for handle in threads {
        handle.join().unwrap();
    }
    
    println!("[host] PHASE 1: All {} bidders have joined successfully", num_bidders);

    // ==================================================================================
    // PHASE 2: BIDDER PROVE - Each bidder runs bidder_prove against other bidders (parallel)
    // ==================================================================================
    println!("[host] ==================================================================================");
    println!("[host] PHASE 2: Bidder Prove - Generating zero-knowledge proofs for all bidder pairs...");
    println!("[host] ==================================================================================");
    println!("[host] Expected number of proof operations: {} (n*(n-1) where n={})", num_bidders * (num_bidders - 1), num_bidders);
    
    // Prepare bidders data for parallel processing
    let mut bidders_data = Vec::new();
    let mut bidders_data_map = HashMap::new();
    
    for (bidder_id, (n, c, r, p, q, v)) in &bidder_results {
        bidders_data.push((
            bidder_id.clone(),
            n.clone(),
            c.clone(),
            r.clone(),
            v.clone(),
            p.clone(),
            q.clone(),
        ));
        bidders_data_map.insert(bidder_id.clone(), (n.clone(), p.clone(), q.clone()));
    }
    
    // Run Phase 2 in parallel
    let phase2_results = bidders_prove_all(bidders_data, sound_param, sigma);
    
    println!("[host] PHASE 2: All bidder_prove operations completed for {} bidders", num_bidders);

    // ==================================================================================
    // PHASE 3: AUCTIONEER VERIFY - Verify all proof_eval and receipts from all bidders
    // ==================================================================================
    println!("[host] ==================================================================================");
    println!("[host] PHASE 3: Auctioneer Verify - Verifying all evaluation proofs and receipts...");
    println!("[host] ==================================================================================");
    
    if !auctioneer_verify_all(&phase2_results, &bidders_data_map, sound_param) {
        println!("[host] Protocol stopped due to verification failures");
        return;
    }
    
    println!("[host] PHASE 3: All auctioneer verifications passed");

    // ==================================================================================
    // PHASE 4: BIDDER VERIFY ALL & WINNER DETERMINATION - Each bidder verifies other bidders' results
    // ==================================================================================
    println!("[host] ==================================================================================");
    println!("[host] PHASE 4: Bidder Verify All - Each bidder verifies other bidders' results in parallel...");
    println!("[host] ==================================================================================");
    
    // Run the comprehensive bidder verification
    let winner_results = bidder_verify_all(&phase2_results, &bidders_data_map, sound_param);
    
    // Final winner announcement (only show winner id and bid value if there is exactly one)
    let mut winners = Vec::new();
    for (bidder_id, is_winner) in &winner_results {
        if *is_winner {
            winners.push(bidder_id);
        }
    }
    if winners.len() == 1 {
        let winner_id = winners[0];
        let winner_bid = bidder_results.get(winner_id).unwrap().5.clone();
        println!("[host] ðŸŽ‰ WINNER: {} (Bid: {})", winner_id, winner_bid);
    }
}

fn main() {
    println!("==================================================================================");
    println!("ZERO-KNOWLEDGE AUCTION PROTOCOL - 4 PHASE IMPLEMENTATION");
    println!("==================================================================================");
    println!("This implementation follows a 4-phase zero-knowledge auction protocol:");
    println!("");
    println!("PHASE 1: BIDDERS JOIN");
    println!("  - Each bidder generates GM keypair and encrypts their bid");
    println!("  - Runs in parallel for efficiency");
    println!("  - Output: (n_j, c_j, r_j, (p_j, q_j)) for each bidder");
    println!("");
    println!("PHASE 2: BIDDER PROVE");
    println!("  - Each bidder 'j' runs bidder_prove against bidder 'i'");
    println!("  - 'j' = bidder running proof, 'i' = other bidder being compared");
    println!("  - Generates zero-knowledge proofs of bid validity");
    println!("");
    println!("PHASE 3: AUCTIONEER VERIFY");
    println!("  - Auctioneer verifies all proof_eval from all bidders");
    println!("  - Ensures all bidders provided valid zero-knowledge proofs");
    println!("  - Auctioneer acts as trusted verifier");
    println!("");
    println!("PHASE 4: BIDDER VERIFY ALL & WINNER DETERMINATION");
    println!("  - Each bidder verifies other bidders' proofs using bidder_verify_all");
    println!("  - Verifies proof_enc (encryption) and proof_dlog (discrete log)");
    println!("  - Ensures mutual verification between bidders");
    println!("  - Final bid comparison using compare_leq_honest");
    println!("  - Determines winner by comparing against all other bidders");
    println!("  - Runs in parallel for efficiency");
    println!("==================================================================================");
    
    // Choose which example to run
    let run_example = 2; // Change this to 1 or 2 to choose which example to run
    
    if run_example == 1 {
        // Example 1: Run the fixed two-bidders example
        println!("Running Example 1: Two Bidders Example");
        run_two_bidders_example();
    } else if run_example == 2 {
        // Example 2: Run the configurable n-bidders example
        println!("Running Example 2: N Bidders Example (Configurable)");
        let bidders = vec![
            ("Alice".to_string(), BigInt::from(1500)),
            ("Bob".to_string(), BigInt::from(5000)),
            ("Oscar".to_string(), BigInt::from(10000)),
        ];
        run_n_bidders_example(bidders);
    } else {
        println!("Invalid example number. Please set run_example to 1 or 2.");
    }
}

fn verify_proof_enc(proof: Vec<Vec<Vec<BigInt>>>) -> bool {
    let n1 = &proof[0][0][0];

    let c1: &Vec<BigInt> = &proof[1][0];

    let r1t4s: &Vec<Vec<BigInt>> = &proof[2];

    let h = hash_flat(r1t4s);
    let bitstring =
        format!("{:0256b}", BigInt::from_bytes_be(num_bigint::Sign::Plus, &h.to_be_bytes()));

    let mut success = true;

    for (i, bit) in bitstring.chars().enumerate().take(40) {
        let q = if bit == '1' { 1 } else { 0 };

        let proof_per_bit: &Vec<BigInt> = &proof[i + 3 /* this is how proof is structured */][0];

        for (j, c1_val) in c1.iter().enumerate() {
            let a = &r1t4s[i][j];
            let rhs = (a * c1_val.modpow(&BigInt::from(2 * q), n1)) % n1;

            let r = &proof_per_bit[j];
            let lhs = r.modpow(&BigInt::from(4), n1);

            if lhs != rhs {
                success = false;
            }
        }
    }

    success
}

fn verify_dlog_eq(
    n: &BigInt,
    y: &BigInt,
    y_pow_r: &BigInt,
    z_pow_r: &BigInt,
    p_dlog: &[(BigInt, BigInt, BigInt)],
    k: Option<usize>,
) -> bool {
    let k = k.unwrap_or(/* default value */ 10) as usize;
    if p_dlog.len() < k {
        // println!("Insufficient number of rounds");
        return false;
    }

    // println!("Sufficient number of rounds test: Passed");

    let z = n - BigInt::one();

    for (i, proof) in p_dlog.iter().take(k).enumerate() {
        let (t1, t2, s) = proof;
        let rng = set_rand_seed(&[
            y.clone(),
            z.clone(),
            y_pow_r.clone(),
            z_pow_r.clone(),
            t1.clone(),
            t2.clone(),
            BigInt::from(i),
        ]);

        let c = get_rand_jn1(n, Some(rng));

        if y.modpow(s, n) != t1 * y_pow_r.modpow(&c, n) % n {
            return false;
        }

        if z.modpow(s, n) != t2 * z_pow_r.modpow(&c, n) % n {
            return false;
        }
    }
    true
}

fn verify_shuffle(proof: &HashMap<u32, StrainProof>, n2: &BigInt, res: &[Vec<BigInt>]) -> bool {
    let challenges_length = 40;
    let StrainProof::HashInput(hash_input) = &proof[&0] else { todo!() };

    let h = hash_flat(hash_input);
    let bitstring =
        format!("{:0256b}", BigInt::from_bytes_be(num_bigint::Sign::Plus, &h.to_be_bytes()));

    let ae_permutation = &hash_input[&0].0;
    let mut am_permutations = HashMap::new();
    let mut me_permutations = HashMap::new();

    for i in 0..challenges_length {
        let (am_permutation, me_permutation) = &hash_input[&(i + 1)];
        am_permutations.insert(i, am_permutation.clone());
        me_permutations.insert(i, me_permutation.clone());
    }

    let mut success = true;

    for (i, bit) in bitstring.chars().enumerate().take(challenges_length as usize) {
        if bit == '0' {
            // Open A-M permutation
            if let Some(StrainProof::AMPermutations((am_perm_desc, am_reencrypt_factors))) =
                &proof.get(&((i as u32) + 1))
            {
                for j in 0..am_perm_desc.len() {
                    for k in 0..challenges_length {
                        let lhs = &am_permutations[&(i as u32)][&am_perm_desc[&(j as u32)]][&k];
                        let r: &_ = &am_reencrypt_factors[j][k as usize];
                        let rsquare = r.modpow(&BigInt::from(2), n2);
                        let rhs = (rsquare * &res[j][k as usize]) % n2;
                        if lhs != &rhs {
                            success = false;
                        }
                    }
                }
            }
        } else {
            // Open M-E permutation
            if let Some(StrainProof::MEPermutations((me_perm_desc, me_reencrypt_factors))) =
                &proof.get(&((i as u32) + 1))
            {
                for j in 0..me_perm_desc.len() {
                    for k in 0..challenges_length {
                        let lhs = &ae_permutation[&me_perm_desc[&(j as u32)]][&k];
                        let r: &BigInt = &me_reencrypt_factors[&(j as u32)][&k];
                        let rsquare = r.modpow(&BigInt::from(2), n2);
                        let rhs = (rsquare * &me_permutations[&(i as u32)][&(j as u32)][&k]) % n2;
                        if lhs != &rhs {
                            success = false;
                        }
                    }
                }
            }
        }
    }

    success
}
