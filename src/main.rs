// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
extern crate num_bigint;
extern crate risc0_zkvm;
extern crate zk_auctions_core;
extern crate zk_auctions_methods;

use num_bigint::BigInt;
use num_traits::One;
 
use risc0_zkvm::{default_prover, serde::from_slice, ExecutorEnv};
use std::collections::HashMap;
use std::thread;
use std::sync::mpsc;
use std::sync::{Arc, Mutex};
use zk_auctions_core::gm::{get_next_random, generate_keys, encrypt_gm};
use zk_auctions_core::utils::rand32;
use zk_auctions_core::protocols::strain::auctioneer::{Auctioneer, StrainAuctioneer};
use zk_auctions_core::utils::{
    compare_leq_honest, get_rand_jn1, hash_flat, set_rand_seed, StrainProof,
};
use zk_auctions_methods::{BIDDER_PROVER_ELF, BIDDER_PROVER_ID, BIDDER_JOIN_ELF, BIDDER_JOIN_ID};

// Struct to store bidder prove results
#[derive(Clone)]
struct BidderProveResult {
    proof_eval: Vec<Vec<Vec<BigInt>>>,
    plaintext_and_coins: Vec<Vec<(BigInt, BigInt, BigInt)>>,
    n_j_from_proof: BigInt,
    proof_enc: Vec<Vec<Vec<BigInt>>>,
    proof_dlog: Vec<(BigInt, BigInt, BigInt)>,
    y_j: BigInt,
    y_pow_r: BigInt,
    z_pow_r: BigInt,
    proof_shuffle: HashMap<u32, StrainProof>,
    res: Vec<Vec<BigInt>>,
}

fn auctioneer_verify(
    proof_eval: &Vec<Vec<Vec<BigInt>>>,
    plaintext_and_coins: &Vec<Vec<(BigInt, BigInt, BigInt)>>,
    n_i: &BigInt,
    n_j: &BigInt,
    sound_param: usize,
) {
    let auctioneer = Auctioneer::new();
    let eval_res = Some(auctioneer.verify_eval(
        proof_eval.clone(),
        plaintext_and_coins.clone(),
        n_i,
        n_j,
        sound_param,
    ));
    assert!(eval_res.is_some(), "`proof_eval` verification failed.");
    println!("[host] proof_eval verification passed.");
}

fn bidder_join(bidder_id: String, bid_value: BigInt) -> (BigInt, Vec<BigInt>, Vec<BigInt>, (BigInt, BigInt)) {
    println!("[host] Starting bidder_join for bidder: {}", bidder_id);
    
    // Create environment for the bidder_join guest method
    let mut private_output = Vec::new();
    let env = ExecutorEnv::builder()
        .write(&bidder_id)
        .expect("Failed to add bidder_id")
        .write(&bid_value)
        .expect("Failed to add bid_value")
        .stdout(&mut private_output)
        .build()
        .unwrap();
    
    println!("[host] ExecutorEnv built for bidder_join. Running zkVM...");
    
    // Run the bidder_join guest method
    let session = default_prover();
    let receipt = session.prove(env, BIDDER_JOIN_ELF).unwrap().receipt;
    println!("[host] zkVM proof generated for bidder_join. Verifying...");
    receipt.verify(BIDDER_JOIN_ID).unwrap();
    println!("[host] zkVM proof verified for bidder_join.");
    
    // Read private output (private key components)
    let (p_j, q_j): (BigInt, BigInt) = from_slice(&private_output)
        .expect("Failed to deserialize private key data");
    
    // Read public output from journal
    let (n_j, c_j, r_j): (BigInt, Vec<BigInt>, Vec<BigInt>) = receipt.journal.decode()
        .expect("Failed to decode public results");
    
    println!("[host] Bidder {} generated public key n_j = {}", bidder_id, n_j);
    println!("[host] Bidder {} encrypted value c_j (len={})", bidder_id, c_j.len());
    
    (n_j, c_j, r_j, (p_j, q_j))
}

fn mock_bidder_join(bidder_id: String, bid_value: BigInt) -> (BigInt, Vec<BigInt>, Vec<BigInt>, (BigInt, BigInt)) {
    println!("[host] Starting mock_bidder_join for bidder: {}", bidder_id);
    
    // Generate keys using pure Rust (same as zkVM version)
    let keys_j = generate_keys(None);
    let n_j = keys_j.pub_key;
    let (p_j, q_j) = keys_j.priv_key;
    
    // Generate random values using pure Rust
    let r_j: Vec<BigInt> = rand32(&n_j);
    
    // Encrypt the bid value using pure Rust
    let c_j = encrypt_gm(&bid_value, &n_j);
    
    println!("[host] Mock bidder {} generated public key n_j = {}", bidder_id, n_j);
    println!("[host] Mock bidder {} encrypted value c_j (len={})", bidder_id, c_j.len());
    
    (n_j, c_j, r_j, (p_j, q_j))
}

fn run_phase2_parallel(
    bidders: Vec<(String, BigInt, Vec<BigInt>, Vec<BigInt>, BigInt, BigInt, BigInt)>, // (id, n, c, r, v, p, q)
    sound_param: usize,
    sigma: BigInt,
) -> HashMap<String, Vec<BidderProveResult>> {
    println!("[host] PHASE 2: Running bidder_prove in parallel for all bidder pairs...");
    
    let mut results: HashMap<String, Vec<BidderProveResult>> = HashMap::new();
    let results_mutex = Arc::new(Mutex::new(&mut results));
    let (tx, rx) = mpsc::channel();
    
    // Create all possible bidder pairs
    let mut threads = Vec::new();
    
    for i in 0..bidders.len() {
        for j in 0..bidders.len() {
            if i != j {
                let (bidder_i_id, n_i, c_i, r_i, v_i, p_i, q_i) = bidders[i].clone();
                let (bidder_j_id, n_j, c_j, r_j, v_j, p_j, q_j) = bidders[j].clone();
                let tx_clone = tx.clone();
                let sigma_clone = sigma.clone();
                
                let handle = thread::spawn(move || {
                    println!("[host] Starting bidder_prove: {} vs {}", bidder_j_id, bidder_i_id);
                    
                    let (proof_eval, plaintext_and_coins, n_j_from_proof, proof_enc, (proof_dlog, y_j, y_pow_r, z_pow_r), (proof_shuffle, res)) = 
                        bidder_prove(bidder_j_id.clone(), c_i, n_i, r_i, n_j, r_j, v_j, p_j, q_j, sound_param, sigma_clone);
                    
                    let result = BidderProveResult {
                        proof_eval,
                        plaintext_and_coins,
                        n_j_from_proof,
                        proof_enc,
                        proof_dlog,
                        y_j,
                        y_pow_r,
                        z_pow_r,
                        proof_shuffle,
                        res,
                    };
                    
                    println!("[host] Completed bidder_prove: {} vs {}", bidder_j_id, bidder_i_id);
                    tx_clone.send((bidder_j_id, bidder_i_id, result)).unwrap();
                });
                
                threads.push(handle);
            }
        }
    }
    
    // Collect results
    for _ in 0..threads.len() {
        let (bidder_j_id, bidder_i_id, result) = rx.recv().unwrap();
        results.entry(bidder_j_id).or_insert_with(Vec::new).push(result);
    }
    
    // Wait for all threads to complete
    for handle in threads {
        handle.join().unwrap();
    }
    
    println!("[host] PHASE 2: All bidder_prove operations completed");
    results
}

fn bidder_prove(
    bidder_id: String,
    c_i: Vec<BigInt>,
    n_i: BigInt,
    r_i: Vec<BigInt>,
    n_j: BigInt,
    r_j: Vec<BigInt>,
    v_j: BigInt,
    p_j: BigInt,
    q_j: BigInt,
    sound_param: usize,
    sigma: BigInt,
) -> (
    Vec<Vec<Vec<BigInt>>>,
    Vec<Vec<(BigInt, BigInt, BigInt)>>,
    BigInt,
    Vec<Vec<Vec<BigInt>>>,
    (Vec<(BigInt, BigInt, BigInt)>, BigInt, BigInt, BigInt),
    (HashMap<u32, StrainProof>, Vec<Vec<BigInt>>),
) {
    let mut rand1: Vec<Vec<BigInt>> = Vec::with_capacity(32);
    let mut rand2: Vec<Vec<BigInt>> = Vec::with_capacity(32);
    let mut rand3: Vec<Vec<BigInt>> = Vec::with_capacity(32);
    let mut rand4: Vec<Vec<BigInt>> = Vec::with_capacity(32);

    for _ in 0..32 {
        let mut x = Vec::with_capacity(128);
        let mut y = Vec::with_capacity(128);
        let mut x2 = Vec::with_capacity(128);
        let mut y2 = Vec::with_capacity(128);
        for _ in 0..128 {
            x.push(get_next_random(&n_i));
            y.push(get_next_random(&n_i));
            x2.push(get_next_random(&n_i));
            y2.push(get_next_random(&n_i));
        }
        rand1.push(x);
        rand2.push(y);
        rand3.push(x2);
        rand4.push(y2);
    }

    let mut private_output = Vec::new();
    println!("[host] Building ExecutorEnv...");
    let env = ExecutorEnv::builder()
        .write(&bidder_id)
        .expect("Failed to add guest_id")
        .write(&(&n_j, &r_j, &v_j, &p_j, &q_j))
        .expect("Failed to add bidder j data")
        .write(&(&c_i, &n_i, &r_i))
        .expect("Failed to add bidder i data")
        .write(&(&sigma, &(sound_param as u32)))
        .expect("Failed to add parameters")
        .write(&(&rand1, &rand2, &rand3, &rand4))
        .expect("Failed to add random values")
        .stdout(&mut private_output)
        .build()
        .unwrap();
    println!("[host] ExecutorEnv built successfully.");

    let session = default_prover();
    println!("[host] Running zkVM (prove)...");
    let receipt = session.prove(env, BIDDER_PROVER_ELF).unwrap().receipt;
    println!("[host] zkVM proof generated. Verifying...");
    receipt.verify(BIDDER_PROVER_ID).unwrap();
    println!("[host] zkVM proof verified.");

    println!("[host] Reading private output...");
    let (proof_eval, plaintext_and_coins): (
        Vec<Vec<Vec<BigInt>>>,
        Vec<Vec<(BigInt, BigInt, BigInt)>>,
    ) = from_slice(&private_output).expect("Failed to deserialize private data");
    println!("[host] Private output deserialization successful.");

    println!("[host] Decoding public results from journal...");
    let (n_j, proof_enc, proof_dlog_tuple, proof_shuffle_tuple): (
        BigInt,
        Vec<Vec<Vec<BigInt>>>,
        (Vec<(BigInt, BigInt, BigInt)>, BigInt, BigInt, BigInt),
        (HashMap<u32, StrainProof>, Vec<Vec<BigInt>>),
    ) = receipt.journal.decode().expect("Failed to decode all results");
    println!("[host] Got n_j = {}", n_j);

    (proof_eval, plaintext_and_coins, n_j, proof_enc, proof_dlog_tuple, proof_shuffle_tuple)
}

fn bidder_verify(
    proof_enc: Vec<Vec<Vec<BigInt>>>,
    proof_dlog: Vec<(BigInt, BigInt, BigInt)>,
    y_j: BigInt,
    y_pow_r: BigInt,
    z_pow_r: BigInt,
    n_j_from_proof: &BigInt,
    sound_param: usize,
    res: Vec<Vec<BigInt>>,
    p_i: BigInt,
    q_i: BigInt,
) {
    println!("[host] Verifying proof_enc...");
    assert!(verify_proof_enc(proof_enc));
    println!("[host] proof_enc verification passed.");

    println!("[host] Verifying dlog proof...");
    assert!(verify_dlog_eq(n_j_from_proof, &y_j, &y_pow_r, &z_pow_r, &proof_dlog, Some(sound_param)));
    println!("[host] dlog proof verification passed.");

    // Final bid comparison using private key
    println!("[host] Comparing bids using compare_leq_honest...");
    if compare_leq_honest(&res, &(p_i, q_i)) {
        println!("The second bidder's bid is less than or equal to the first bidder's bid.");
    } else {
        println!("The second bidder's bid is greater than the first bidder's bid.");
    }

    // let success = verify_shuffle(&proof_shuffle, &n_j, &res);
    // assert!(success, "verify_shuffle failed");
}

fn run_two_bidders() { 
    // ==================================================================================
    // PHASE 1: BIDDERS JOIN - Generate keys and encrypt bid values
    // ==================================================================================
    // Each bidder generates their own GM keypair (n_j, p_j, q_j) and encrypts their bid
    // This phase runs in parallel for all bidders to reduce total execution time
    // Output: Each bidder gets (n_j, c_j, r_j, (p_j, q_j)) where:
    //   - n_j: public key
    //   - c_j: encrypted bid value  
    //   - r_j: random values used in encryption
    //   - (p_j, q_j): private key components
    // ==================================================================================
    println!("[host] PHASE 1: Bidders Join - Generating keys and encrypting bids...");
    
    // Create channels for communication between threads
    let (tx, rx) = mpsc::channel();
    
    // Spawn first bidder thread
    let tx1 = tx.clone();
    let handle1 = thread::spawn(move || {
        let v_i: BigInt = BigInt::from(1500);
        println!("[host] Starting bidder1 thread with bid v_i = {}", v_i);
        let result = mock_bidder_join("bidder1".to_string(), v_i.clone());
        println!("[host] Bidder1 thread completed");
        tx1.send(("bidder1", v_i, result)).unwrap();
    });
    
    // Spawn second bidder thread
    let handle2 = thread::spawn(move || {
        let v_j: BigInt = BigInt::from(2000);
        println!("[host] Starting bidder2 thread with bid v_j = {}", v_j);
        let result = mock_bidder_join("bidder2".to_string(), v_j.clone());
        println!("[host] Bidder2 thread completed");
        tx.send(("bidder2", v_j, result)).unwrap();
    });
    
    // Wait for both threads to complete and collect results
    println!("[host] Waiting for both bidders to complete...");
    let mut bidder1_result = None;
    let mut bidder2_result = None;
    
    for _ in 0..2 {
        let (bidder_id, bid_value, (n, c, r, (p, q))) = rx.recv().unwrap();
        match bidder_id {
            "bidder1" => {
                bidder1_result = Some((n, c, r, (p, q), bid_value));
                println!("[host] Received bidder1 results");
            },
            "bidder2" => {
                bidder2_result = Some((n, c, r, (p, q), bid_value));
                println!("[host] Received bidder2 results");
            },
            _ => panic!("Unknown bidder ID"),
        }
    }
    
    // Join threads to ensure they're finished
    handle1.join().unwrap();
    handle2.join().unwrap();
    
    // Extract results
    let (n_1, c_1, r_1, (p_1, q_1), v_1) = bidder1_result.unwrap();
    let (n_2, c_2, r_2, (p_2, q_2), v_2) = bidder2_result.unwrap();
    
    println!("[host] First bidder's bid v_1 = {}", v_1);
    println!("[host] Second bidder's bid v_2 = {}", v_2);

    // ==================================================================================
    // PHASE 2: BIDDER PROVE - Each bidder runs bidder_prove against other bidders
    // ==================================================================================
    // Each bidder "j" runs the zkVM bidder_prove guest method with respect to bidder "i"
    // - "j" = the bidder running the proof (me)
    // - "i" = the other bidder being compared against
    // This generates zero-knowledge proofs that bidder j's bid is valid
    // Output: proof_eval, proof_enc, proof_dlog, and comparison results
    // ==================================================================================
    println!("[host] PHASE 2: Bidder Prove - Generating zero-knowledge proofs in parallel...");

    let sound_param: usize = 40;
    let sigma: BigInt = BigInt::from(40);
    println!("[host] sound_param = {} sigma = {}", sound_param, sigma);

    // Prepare bidders data for parallel processing
    let bidders = vec![
        ("bidder1".to_string(), n_1.clone(), c_1, r_1, v_1, p_1.clone(), q_1.clone()),
        ("bidder2".to_string(), n_2, c_2, r_2, v_2, p_2, q_2),
    ];

    // Run Phase 2 in parallel
    let phase2_results = run_phase2_parallel(bidders, sound_param, sigma);
    
    // For now, let's use the first result for the rest of the protocol
    // In a full implementation, you'd process all results
    let bidder2_results = phase2_results.get("bidder2").unwrap();
    let first_result = &bidder2_results[0];
    
    let proof_eval = first_result.proof_eval.clone();
    let plaintext_and_coins = first_result.plaintext_and_coins.clone();
    let n_j_from_proof = first_result.n_j_from_proof.clone();
    let proof_enc = first_result.proof_enc.clone();
    let proof_dlog = first_result.proof_dlog.clone();
    let y_j = first_result.y_j.clone();
    let y_pow_r = first_result.y_pow_r.clone();
    let z_pow_r = first_result.z_pow_r.clone();
    let proof_shuffle = first_result.proof_shuffle.clone();
    let res = first_result.res.clone();

    // ==================================================================================
    // PHASE 3: AUCTIONEER VERIFY - Verify all proof_eval from all bidders
    // ==================================================================================
    // The auctioneer verifies the evaluation proofs (proof_eval) from all bidders
    // This ensures that all bidders have provided valid zero-knowledge proofs
    // The auctioneer acts as a trusted verifier in this phase
    // ==================================================================================
    println!("[host] PHASE 3: Auctioneer Verify - Verifying all evaluation proofs...");
    
    // Verify proof_eval separately
    println!("[host] Verifying proof_eval...");
    println!("[host] proof_eval = {:?}", proof_eval);
    println!("[host] plaintext_and_coins = {:?}", plaintext_and_coins);
    println!("[host] n_1 = {:?}", n_1);
    println!("[host] n_j_from_proof = {:?}", n_j_from_proof);
    println!("[host] sound_param = {:?}", sound_param);

    auctioneer_verify(&proof_eval, &plaintext_and_coins, &n_1, &n_j_from_proof, sound_param);

    // ==================================================================================
    // PHASE 4: BIDDER VERIFY - Bidders verify each other's proofs and compare bids
    // ==================================================================================
    // Each bidder verifies the proofs from other bidders using bidder_verify
    // This includes verifying proof_enc (encryption proof) and proof_dlog (discrete log proof)
    // This ensures mutual verification between bidders
    // Also includes the final bid comparison using compare_leq_honest
    // ==================================================================================
    println!("[host] PHASE 4: Bidder Verify - Bidders verifying each other's proofs and comparing bids...");
    
    // Call bidder_verify to verify the other proofs and compare bids
    bidder_verify(
        proof_enc,
        proof_dlog,
        y_j,
        y_pow_r,
        z_pow_r,
        &n_j_from_proof,
        sound_param,
        res,
        p_1,
        q_1,
    );
}

fn main() {
    println!("==================================================================================");
    println!("ZERO-KNOWLEDGE AUCTION PROTOCOL - 4 PHASE IMPLEMENTATION");
    println!("==================================================================================");
    println!("This implementation follows a 4-phase zero-knowledge auction protocol:");
    println!("");
    println!("PHASE 1: BIDDERS JOIN");
    println!("  - Each bidder generates GM keypair and encrypts their bid");
    println!("  - Runs in parallel for efficiency");
    println!("  - Output: (n_j, c_j, r_j, (p_j, q_j)) for each bidder");
    println!("");
    println!("PHASE 2: BIDDER PROVE");
    println!("  - Each bidder 'j' runs bidder_prove against bidder 'i'");
    println!("  - 'j' = bidder running proof, 'i' = other bidder being compared");
    println!("  - Generates zero-knowledge proofs of bid validity");
    println!("");
    println!("PHASE 3: AUCTIONEER VERIFY");
    println!("  - Auctioneer verifies all proof_eval from all bidders");
    println!("  - Ensures all bidders provided valid zero-knowledge proofs");
    println!("  - Auctioneer acts as trusted verifier");
    println!("");
    println!("PHASE 4: BIDDER VERIFY & COMPARE");
    println!("  - Each bidder verifies other bidders' proofs using bidder_verify");
    println!("  - Verifies proof_enc (encryption) and proof_dlog (discrete log)");
    println!("  - Ensures mutual verification between bidders");
    println!("  - Final bid comparison using compare_leq_honest");
    println!("  - Determines relative ordering of bids using private keys");
    println!("==================================================================================");
    println!("");
    
    run_two_bidders();
}

fn verify_proof_enc(proof: Vec<Vec<Vec<BigInt>>>) -> bool {
    let n1 = &proof[0][0][0];

    let c1: &Vec<BigInt> = &proof[1][0];

    let r1t4s: &Vec<Vec<BigInt>> = &proof[2];

    let h = hash_flat(r1t4s);
    let bitstring =
        format!("{:0256b}", BigInt::from_bytes_be(num_bigint::Sign::Plus, &h.to_be_bytes()));

    let mut success = true;

    for (i, bit) in bitstring.chars().enumerate().take(40) {
        let q = if bit == '1' { 1 } else { 0 };

        let proof_per_bit: &Vec<BigInt> = &proof[i + 3 /* this is how proof is structured */][0];

        for (j, c1_val) in c1.iter().enumerate() {
            let a = &r1t4s[i][j];
            let rhs = (a * c1_val.modpow(&BigInt::from(2 * q), n1)) % n1;

            let r = &proof_per_bit[j];
            let lhs = r.modpow(&BigInt::from(4), n1);

            if lhs != rhs {
                success = false;
            }
        }
    }

    success
}

fn verify_dlog_eq(
    n: &BigInt,
    y: &BigInt,
    y_pow_r: &BigInt,
    z_pow_r: &BigInt,
    p_dlog: &[(BigInt, BigInt, BigInt)],
    k: Option<usize>,
) -> bool {
    let k = k.unwrap_or(/* default value */ 10) as usize;
    if p_dlog.len() < k {
        // println!("Insufficient number of rounds");
        return false;
    }

    // println!("Sufficient number of rounds test: Passed");

    let z = n - BigInt::one();

    for (i, proof) in p_dlog.iter().take(k).enumerate() {
        let (t1, t2, s) = proof;
        let rng = set_rand_seed(&[
            y.clone(),
            z.clone(),
            y_pow_r.clone(),
            z_pow_r.clone(),
            t1.clone(),
            t2.clone(),
            BigInt::from(i),
        ]);

        let c = get_rand_jn1(n, Some(rng));

        if y.modpow(s, n) != t1 * y_pow_r.modpow(&c, n) % n {
            return false;
        }

        if z.modpow(s, n) != t2 * z_pow_r.modpow(&c, n) % n {
            return false;
        }
    }
    true
}

fn verify_shuffle(proof: &HashMap<u32, StrainProof>, n2: &BigInt, res: &[Vec<BigInt>]) -> bool {
    let challenges_length = 40;
    let StrainProof::HashInput(hash_input) = &proof[&0] else { todo!() };

    let h = hash_flat(hash_input);
    let bitstring =
        format!("{:0256b}", BigInt::from_bytes_be(num_bigint::Sign::Plus, &h.to_be_bytes()));

    let ae_permutation = &hash_input[&0].0;
    let mut am_permutations = HashMap::new();
    let mut me_permutations = HashMap::new();

    for i in 0..challenges_length {
        let (am_permutation, me_permutation) = &hash_input[&(i + 1)];
        am_permutations.insert(i, am_permutation.clone());
        me_permutations.insert(i, me_permutation.clone());
    }

    let mut success = true;

    for (i, bit) in bitstring.chars().enumerate().take(challenges_length as usize) {
        if bit == '0' {
            // Open A-M permutation
            if let Some(StrainProof::AMPermutations((am_perm_desc, am_reencrypt_factors))) =
                &proof.get(&((i as u32) + 1))
            {
                for j in 0..am_perm_desc.len() {
                    for k in 0..challenges_length {
                        let lhs = &am_permutations[&(i as u32)][&am_perm_desc[&(j as u32)]][&k];
                        let r: &_ = &am_reencrypt_factors[j][k as usize];
                        let rsquare = r.modpow(&BigInt::from(2), n2);
                        let rhs = (rsquare * &res[j][k as usize]) % n2;
                        if lhs != &rhs {
                            success = false;
                        }
                    }
                }
            }
        } else {
            // Open M-E permutation
            if let Some(StrainProof::MEPermutations((me_perm_desc, me_reencrypt_factors))) =
                &proof.get(&((i as u32) + 1))
            {
                for j in 0..me_perm_desc.len() {
                    for k in 0..challenges_length {
                        let lhs = &ae_permutation[&me_perm_desc[&(j as u32)]][&k];
                        let r: &BigInt = &me_reencrypt_factors[&(j as u32)][&k];
                        let rsquare = r.modpow(&BigInt::from(2), n2);
                        let rhs = (rsquare * &me_permutations[&(i as u32)][&(j as u32)][&k]) % n2;
                        if lhs != &rhs {
                            success = false;
                        }
                    }
                }
            }
        }
    }

    success
}
